/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                                                                           *
 *  Copyright (C) 2013-2017 Chuan Ji <ji@chu4n.com>                          *
 *                                                                           *
 *  Licensed under the Apache License, Version 2.0 (the "License");          *
 *  you may not use this file except in compliance with the License.         *
 *  You may obtain a copy of the License at                                  *
 *                                                                           *
 *   http://www.apache.org/licenses/LICENSE-2.0                              *
 *                                                                           *
 *  Unless required by applicable law or agreed to in writing, software      *
 *  distributed under the License is distributed on an "AS IS" BASIS,        *
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *
 *  See the License for the specific language governing permissions and      *
 *  limitations under the License.                                           *
 *                                                                           *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#include "window_manager.hpp"
extern "C" {
#include <X11/Xutil.h>
}
#include <cstring>
#include <algorithm>
#include <glog/logging.h>
#include "util.hpp"

using ::std::max;
using ::std::mutex;
using ::std::string;
using ::std::unique_ptr;

bool WindowManager::wm_detected_;
mutex WindowManager::wm_detected_mutex_;

/// @brief 创建连接到X服务器的WM对象的静态工厂方法
/// @param display_str 是创建窗口的CLI参数，决定WM的实例特性
/// @return 函数返回的是临时unique_ptr，因此是亡值，会调用移动构造函数（因此成立，unique_ptr没有拷贝构造）
unique_ptr<WindowManager> WindowManager::Create(const string& display_str) {
  // 1. Open X display.
  const char* display_c_str =
        display_str.empty() ? nullptr : display_str.c_str();
  Display* display = XOpenDisplay(display_c_str);
  if (display == nullptr) {
    LOG(ERROR) << "Failed to open X display " << XDisplayName(display_c_str);
    return nullptr;
  }
  // 2. Construct WindowManager instance.
  return unique_ptr<WindowManager>(new WindowManager(display));
}

WindowManager::WindowManager(Display* display)
    : display_(CHECK_NOTNULL(display)),
      root_(DefaultRootWindow(display_)), //获取顶层窗口ID
      //REVIEW - 这里协议不是很清楚，注册属性到X server是为了其他的X client能读取这个属性吗？
      WM_PROTOCOLS(XInternAtom(display_, "WM_PROTOCOLS", false)),//不存在就创建，并拿到服务器返回的原子标识
      WM_DELETE_WINDOW(XInternAtom(display_, "WM_DELETE_WINDOW", false)) //不存在就创建，并拿到服务器返回的原子标识
{}

WindowManager::~WindowManager() {
  XCloseDisplay(display_); // WM并不决定X Client的声明周期，因此仅释放自己和自己的X连接
}

void WindowManager::Run() {
  // 1. Initialization.
  //   a. Select events on root window. Use a special error handler so we can
  //   exit gracefully if another window manager is already running.
  // 1. 初始化。
  //   a. 为根窗口指定一个错误处理回调，这样可以在多次启动WM时处理退出工作。
  {
    ::std::lock_guard<mutex> lock(wm_detected_mutex_);

    wm_detected_ = false;
    // 注册错误处理函数
    XSetErrorHandler(&WindowManager::OnWMDetected);
    // 在根窗口上注册子结构重定向，这个函数调用者是当前的WM，因此WM能监听根窗口及其直接子窗口的事件
    XSelectInput(
        display_,
        root_,
        SubstructureRedirectMask | SubstructureNotifyMask); //NOTE - 窗口管理器要能响应子结构重定向事件（手册上只有这两个与子结构重定向的事件掩码）
    XSync(display_, false); //刷新Xclient的输出缓冲区（发送request的）并等待Xserver处理完全部request，false表示不丢弃请求队列中的现有事件

    // 由于前面使用XSync刷新请求缓冲区，这样所有的事件都会被X server处理。此时就能检查是否是多次启动WM了
    // Any errors generated must be handled by the error handler. For each
    // protocol error received by Xlib, XSync() calls the client application's
    // error handling routine. Any events generated by the server are enqueued
    // into the library's event queue.
    if (wm_detected_) {
      LOG(ERROR) << "Detected another window manager on display "
                 << XDisplayString(display_);
      return;
    }
  }
  //   b. Set error handler.
  XSetErrorHandler(&WindowManager::OnXError);
  //   c. Grab X server to prevent windows from changing under us.
  //SECTION - 使用了Grab操作来锁定Xserver，因为接下来要获取所有的窗口，此时不能让Xserver继续创建或销毁窗口
  XGrabServer(display_);
  //   d. Reparent existing top-level windows.
  // 由于启动了窗口管理器，因此此前存在的所有窗口都需要被装饰一下，并设置父窗口
  //     i. Query existing top-level windows.
  Window returned_root, returned_parent;
  Window* top_level_windows;
  unsigned int num_top_level_windows;
  //由于是查询根窗口的所有子窗口，因此就能得到当前所有的子窗口
  //从而对所有子窗口进行reparent/frame
  CHECK(XQueryTree(
      display_,
      root_,
      &returned_root,//根窗口ID
      &returned_parent,//父窗口ID
      &top_level_windows, //子窗口ID数组
      &num_top_level_windows));//子窗口的数量
  CHECK_EQ(returned_root, root_);
  //     ii. Frame each existing top-level window.
  for (unsigned int i = 0; i < num_top_level_windows; ++i) {
    //显然，在Run()调用时，当前存在的所有窗口都是在WM创建前创建的，因此第二个参数为true
    Frame(top_level_windows[i], true);
  }

  //     iii. Free top-level window array. 因为后面不再需要这个数组了，XQueryTree()要求我们使用XFree()释放内存
  XFree(top_level_windows);
  //   e. Ungrab X server.
  XUngrabServer(display_);
  //?SECTION - 使用了UnGrab操作来解锁Xserver

  // 2. Main event loop.
  for (;;) {
    // 1. Get next event.
    XEvent e;
    XNextEvent(display_, &e); //隐含着刷新事件队列
    LOG(INFO) << "Received event: " << ToString(e);

    // 2. Dispatch event.
    switch (e.type) {
      case CreateNotify: //某个Xclient创建了窗口，仅Create还没有Map，因此不可见，因此WM不用执行任何操作（虽然不可见的窗口也由WM管理）
        OnCreateNotify(e.xcreatewindow);
        break;
      case DestroyNotify:
        OnDestroyNotify(e.xdestroywindow);
        break;
      case ReparentNotify:
        OnReparentNotify(e.xreparent);
        break;
      case MapNotify:
        OnMapNotify(e.xmap);
        break;
      case UnmapNotify:
        OnUnmapNotify(e.xunmap);//unmap事件出现在Xclient退出或最小化的时刻
        break;
      case ConfigureNotify:
        OnConfigureNotify(e.xconfigure);
        break;
      case MapRequest:
        OnMapRequest(e.xmaprequest); //显示窗口
        break;
      case ConfigureRequest:
          OnConfigureRequest(e.xconfigurerequest); //原模原样地为接受Xclient的调整窗口属性的请求，啥也没过滤
          break;
      case ButtonPress:
        OnButtonPress(e.xbutton);
        break;
      case ButtonRelease:
        OnButtonRelease(e.xbutton);
        break;
      case MotionNotify:
        // Skip any already pending motion events.
        // 取出与事件e中描述的窗口相匹配的Motion事件，跳过其他不是e所描述的窗口的Motion事件
        while (XCheckTypedWindowEvent(
            display_, e.xmotion.window, MotionNotify, &e)) {}
        OnMotionNotify(e.xmotion);
        break;
      case KeyPress:
        OnKeyPress(e.xkey);
        break;
      case KeyRelease:
        OnKeyRelease(e.xkey);
        break;
      default:
        LOG(WARNING) << "Ignored event";
    }
  }
}

void WindowManager::Frame(Window w, bool was_created_before_window_manager) {
  // Visual properties of the frame to create.
  const unsigned int BORDER_WIDTH = 3;
  const unsigned long BORDER_COLOR = 0xff0000; // 黄色
  const unsigned long BG_COLOR = 0x0000ff; //蓝色

  //以下使用w表示要被frame的窗口

  // We shouldn't be framing windows we've already framed.
  CHECK(!clients_.count(w)); //避免重复frame

  // 1. Retrieve attributes of window to frame.
  // 1. 先获取待frame的窗口的属性，因为要修改它
  XWindowAttributes x_window_attrs;
  CHECK(XGetWindowAttributes(display_, w, &x_window_attrs));

  // 2. If window was created before window manager started, we should frame
  // it only if it is visible and doesn't set override_redirect.
  // 2. 如果窗口是在窗口管理器启动之前创建的，
  // 我们应该只在它 可见(被Map了) 且 没有设置override_redirect 的情况下才对它进行frame
  // 前者加frame没有意义，后者不受WM管理
  if (was_created_before_window_manager) {
    if (x_window_attrs.override_redirect ||
        x_window_attrs.map_state != IsViewable) { //map_state指示窗口是否可见
      return;
    }
  }

  // 3. Create frame. 创建frame窗口同样也会触发CreateNotify事件，但同理，由于是Notify，其实WM没有什么要做的（即OnCreateNotify函数为空）
  const Window frame = XCreateSimpleWindow(
      display_,
      root_,
      x_window_attrs.x,
      x_window_attrs.y,
      x_window_attrs.width,
      x_window_attrs.height,
      BORDER_WIDTH,
      BORDER_COLOR,
      BG_COLOR);
  // 4. Select events on frame.
  // 由于子结构重定向仅适用于直接子窗口，因此在w窗口成为frame窗口的子窗口后，之前在w上注册的子结构重定向失效了，
  // 因此需要在frame窗口上注册子结构重定向，这样frame窗口和w窗口上发生的事件才能被重定向到WM
  XSelectInput(
      display_,
      frame,
      SubstructureRedirectMask | SubstructureNotifyMask);
  // 5. Add client to save set, so that it will be restored and kept alive if we crash.
  XAddToSaveSet(display_, w);
  // 6. Reparent client window.
  // 使得w成为frame的子窗口
  XReparentWindow(
      display_,
      w,
      frame,
      0, 0);  // Offset of client window within frame.
  // 7. Map frame.
  // 显示(Map)窗口的frame
  XMapWindow(display_, frame);
  // 8. Save frame handle.
  clients_[w] = frame; //存入哈希表
  // 9. Grab universal window management actions on client window.
  // 在w上注册键盘和鼠标事件
  // Mod1Mask是alt键
  //   a. Move windows with alt + left button.
  //   设置alt+鼠标左键这种组合键对于窗口w的效果
  XGrabButton(
      display_,
      Button1,
      Mod1Mask,
      w,
      false,
      ButtonPressMask | ButtonReleaseMask | ButtonMotionMask,
      GrabModeAsync, /*定期解除冻结，刷新一下*/
      GrabModeAsync,
      None,
      None);
  //   b. Resize windows with alt + right button.
  XGrabButton(
      display_,
      Button3,
      Mod1Mask,
      w,
      false,
      ButtonPressMask | ButtonReleaseMask | ButtonMotionMask,
      GrabModeAsync,
      GrabModeAsync,
      None,
      None);
  //   c. Kill windows with alt + f4.
  XGrabKey(
      display_,
      XKeysymToKeycode(display_, XK_F4),
      Mod1Mask,
      w,
      false,
      GrabModeAsync,
      GrabModeAsync);
  //   d. Switch windows with alt + tab.
  XGrabKey(
      display_,
      XKeysymToKeycode(display_, XK_Tab),
      Mod1Mask,
      w,
      false,
      GrabModeAsync,
      GrabModeAsync);

  LOG(INFO) << "Framed window " << w << " [" << frame << "]";
}

void WindowManager::Unframe(Window w) {
  CHECK(clients_.count(w));

  // We reverse the steps taken in Frame().
  // unframe的步骤就是倒过来的frame步骤
  const Window frame = clients_[w];
  // 1. Unmap frame.
  XUnmapWindow(display_, frame);
  // 2. Reparent client window.
  // 重新将w窗口设置为root window的直接子窗口
  XReparentWindow(
      display_,
      w,
      root_,
      0, 0);  // Offset of client window within root.
  // 3. Remove client window from save set, as it is now unrelated to us.
  XRemoveFromSaveSet(display_, w);
  // 4. Destroy frame.
  XDestroyWindow(display_, frame);
  // 5. Drop reference to frame handle.
  clients_.erase(w);

  LOG(INFO) << "Unframed window " << w << " [" << frame << "]";
}

void WindowManager::OnCreateNotify(const XCreateWindowEvent& e) {}

void WindowManager::OnDestroyNotify(const XDestroyWindowEvent& e) {}

void WindowManager::OnReparentNotify(const XReparentEvent& e) {}

void WindowManager::OnMapNotify(const XMapEvent& e) {}

void WindowManager::OnUnmapNotify(const XUnmapEvent& e) {
  // If the window is a client window we manage, unframe it upon UnmapNotify.
  // We need the check because we will receive an UnmapNotify event for a
  // frame window we just destroyed ourselves.
  //NOTE - 只对WM管理的客户端窗口进行unframe，frame窗口不需要unframe（废话）
  // 因为我们在Unframe()函数中调用了XUnmapWindow()来unmap Xclient的frame窗口，
  // 因此会触发OnUnmapNotify()，于是出现了递归调用（由于X事件驱动的机制，参数e是刚刚unmap的窗口）
  // 如果我们为frame窗口进行unframe就会出现错误（废话）。同理如果窗口是我们管理的客户端窗口，那么才进行unframe
  if (!clients_.count(e.window)) {
      LOG(INFO) << "Ignore UnmapNotify for non-client window " << e.window;
    return;
  }

  // Ignore event if it is triggered by reparenting a window that was mapped
  // before the window manager started.
  // 
  // Since we receive UnmapNotify events from the SubstructureNotify mask, the
  // event attribute specifies the parent window of the window that was
  // unmapped. This means that an UnmapNotify event from a normal client window
  // should have this attribute set to a frame window we maintain. Only an
  // UnmapNotify event triggered by reparenting a pre-existing window will have
  // this attribute set to the root window.

  // NOTE - 忽略由WM启动之前map的窗口的reparent操作所触发的事件（这中情况发生在Run()，即WM刚刚创建时）
  // 只有当为WM创建之前就存在的窗口重设父窗口时触发的UnmapNotify事件才会将这个事件传播到根窗口（因为这些窗口还暂时不属于WM管理，没有被子结构重定向）。
  if (e.event == root_) {
    LOG(INFO) << "Ignore UnmapNotify for reparented pre-existing window "
              << e.window;
    return;
  }

  // 因为我们是通过SubstructureNotify掩码来设置接受UnmapNotify事件的，所以这里的event的成员中会包含被unmap的窗口的父窗口（因为子结构重定向）。
  // 这意味着来自普通客户端窗口的UnmapNotify事件应该也作用于frame窗口，这样才会实现客户端和frame窗口一起最小化或关闭
  Unframe(e.window);
}

void WindowManager::OnConfigureNotify(const XConfigureEvent& e) {}

void WindowManager::OnMapRequest(const XMapRequestEvent& e) {
  // 1. Frame or re-frame window.
  // 显然此时WM已经运行起来了，所以第二个参数为false
  Frame(e.window, false);
  // 2. Actually map window.
  XMapWindow(display_, e.window);
}

void WindowManager::OnConfigureRequest(const XConfigureRequestEvent& e) {
  XWindowChanges changes{
    .x = e.x,
    .y = e.y,
    .width = e.width,
    .height = e.height,
    .border_width = e.border_width,
    .sibling = e.above,
    .stack_mode = e.detail
  };
  if (clients_.count(e.window)) { // 如果该窗口拥有frame窗口，则frame窗口也需要改变config
    const Window frame = clients_[e.window];
    XConfigureWindow(display_, frame, e.value_mask, &changes);
    LOG(INFO) << "Resize [" << frame << "] to " << Size<int>(e.width, e.height);
  }
  XConfigureWindow(display_, e.window, e.value_mask, &changes);
  LOG(INFO) << "Resize " << e.window << " to " << Size<int>(e.width, e.height);
}

void WindowManager::OnButtonPress(const XButtonEvent& e) { // 鼠标按下事件
  //检查并获取frame窗口
  CHECK(clients_.count(e.window));
  const Window frame = clients_[e.window];

  // 1. Save initial cursor position.
  // 这里获取按键按下时窗口的初始位置
  drag_start_pos_ = Position<int>(e.x_root, e.y_root);

  // 2. Save initial window info.
  // 保存此时的窗口几何属性，留着之后的操作备用
  Window returned_root;
  int x, y;
  unsigned width, height, border_width, depth;
  CHECK(XGetGeometry(
      display_,
      frame,
      &returned_root,
      &x, &y,
      &width, &height,
      &border_width,
      &depth));
  drag_start_frame_pos_ = Position<int>(x, y);
  drag_start_frame_size_ = Size<int>(width, height);

  // 3. Raise clicked window to top.
  XRaiseWindow(display_, frame);
}

void WindowManager::OnButtonRelease(const XButtonEvent& e) {}

void WindowManager::OnMotionNotify(const XMotionEvent& e) {
  //检查并获取frame窗口，因为frame窗口也要跟着一起变换
  CHECK(clients_.count(e.window));
  const Window frame = clients_[e.window];
  //得到拖拽的终点和位移
  const Position<int> drag_pos(e.x_root, e.y_root);
  const Vector2D<int> delta = drag_pos - drag_start_pos_;
  /*
  - Button1Mask：鼠标左键
  - Button2Mask：鼠标中键
  - Button3Mask：鼠标右键
  */
  if (e.state & Button1Mask ) {
    // alt + left button: Move window.
    const Position<int> dest_frame_pos = drag_start_frame_pos_ + delta;
    XMoveWindow(
        display_,
        frame,
        dest_frame_pos.x, dest_frame_pos.y);
  } else if (e.state & Button3Mask) {
    // alt + right button: Resize window.
    // Window dimensions cannot be negative.
    const Vector2D<int> size_delta(
        max(delta.x, -drag_start_frame_size_.width),
        max(delta.y, -drag_start_frame_size_.height));
    const Size<int> dest_frame_size = drag_start_frame_size_ + size_delta;
    // 1. Resize frame.
    XResizeWindow(
        display_,
        frame,
        dest_frame_size.width, dest_frame_size.height);
    // 2. Resize client window.
    XResizeWindow(
        display_,
        e.window,
        dest_frame_size.width, dest_frame_size.height);
  }
}

void WindowManager::OnKeyPress(const XKeyEvent& e) {
  //Mod1Mask是左Alt键
  //确认是Alt被按下
  if ((e.state & Mod1Mask) &&
      (e.keycode == XKeysymToKeycode(display_, XK_F4))) {
    // alt + f4: Close window.
    //
    // There are two ways to tell an X window to close. The first is to send it
    // a message of type WM_PROTOCOLS and value WM_DELETE_WINDOW. If the client
    // has not explicitly marked itself as supporting this more civilized
    // behavior (using XSetWMProtocols()), we kill it with XKillClient().
    /*
    有两种方法可以让窗口关闭：
    - 第一种是发送一个类型为WM_PROTOCOLS的request报文给要关闭的窗口，值为WM_DELETE_WINDOW，这样当Xclient接收到这个报文时，就能关闭窗口
    - 否则如果客户端没有使用XSetWMProtocols()来标记自己支持这种更安全的关闭方式，就得使用XKillClient()强制关闭窗口。
    */
    // 因此先检查要关闭的窗体是否有WM_DELETE_WINDOW的属性
    Atom* supported_protocols;
    int num_supported_protocols;
    if (XGetWMProtocols(display_,
                        e.window,
                        &supported_protocols,
                        &num_supported_protocols) &&
        (::std::find(supported_protocols,
                     supported_protocols + num_supported_protocols,
                     WM_DELETE_WINDOW) !=
         supported_protocols + num_supported_protocols)) {
      LOG(INFO) << "Gracefully deleting window " << e.window;
      // 1. Construct message.
      XEvent msg;
      memset(&msg, 0, sizeof(msg));
      msg.xclient.type = ClientMessage;
      msg.xclient.message_type = WM_PROTOCOLS;
      msg.xclient.window = e.window;
      msg.xclient.format = 32;
      msg.xclient.data.l[0] = WM_DELETE_WINDOW;
      // 2. Send message to window to be closed.
      CHECK(XSendEvent(display_, e.window, false, NoEventMask,
                       &msg)); // 事件不传播
      free(supported_protocols);
    } else {
      LOG(INFO) << "Killing window " << e.window;
      XKillClient(display_, e.window);
    }
  } else if ((e.state & Mod1Mask) &&
             (e.keycode == XKeysymToKeycode(display_, XK_Tab))) {
    // alt + tab: Switch window.
    // 1. Find next window.
    auto i = clients_.find(e.window);
    CHECK(i != clients_.end());
    ++i;//拿到当前的窗口的下一个窗口的迭代器
    if (i == clients_.end()) 
      i = clients_.begin();
    // 2. Raise and set focus.
    XRaiseWindow(display_, i->second);
    XSetInputFocus(display_, i->first, RevertToPointerRoot, CurrentTime);
  }
}

void WindowManager::OnKeyRelease(const XKeyEvent& e) {}

int WindowManager::OnXError(Display* display, XErrorEvent* e) {
  const int MAX_ERROR_TEXT_LENGTH = 1024;
  char error_text[MAX_ERROR_TEXT_LENGTH];
  XGetErrorText(display, e->error_code, error_text, sizeof(error_text));
  LOG(ERROR) << "Received X error:\n"
             << "    Request: " << int(e->request_code)
             << " - " << XRequestCodeToString(e->request_code) << "\n"
             << "    Error code: " << int(e->error_code)
             << " - " << error_text << "\n"
             << "    Resource ID: " << e->resourceid;
  // The return value is ignored.
  return 0;
}

int WindowManager::OnWMDetected(Display* display, XErrorEvent* e) {
  // In the case of an already running window manager, the error code from
  // XSelectInput is BadAccess. We don't expect this handler to receive any
  // other errors.
  // 此时WM已经启动，因此多次启动WM返回的错误码应当是BadAccess
  CHECK_EQ(static_cast<int>(e->error_code), BadAccess);
  // Set flag.
  wm_detected_ = true;
  // The return value is ignored.
  return 0;
}
